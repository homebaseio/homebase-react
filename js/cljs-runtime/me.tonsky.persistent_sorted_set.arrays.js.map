{"version":3,"sources":["me/tonsky/persistent_sorted_set/arrays.cljc"],"mappings":";AAQA,AAAA,AAAOA,AAASC,AAAIC,AAAKC;AAAzB,AACE,AAAI,AAAA,AAAKF;AAAKC;;AAAKC;;;AAIlB,AAAA,AAAaC,AAAYC;AAAzB,AAA+B,AAAAC,AAAWD;;AAO1C,AAAA,AAAaE,AAAYC;AAAzB,AACE,AAACC,AAAO,AAAKC,AAAEC;AAAP,AAAU,AAAOD,AAAEC;;AAAGD;AAAG,AAAAJ,AAAYE;;AAqDlD,AAAA,AAAMI,AAAQC;AAAd,AAEW,AAAA,AAAQA;;AAGnB,AAAA,AAAMC,AAASJ,AAAEK;AAAjB,AACW,AAASL,AAAEK;;AASnB,AAAA,AAAMC,AAAMC,AAAEC;AAAd,AACE,AAAMA,AAAID;;AAYf,AAAA,AAAME,AAAOD,AAAIE;AAAjB,AACW,AAAOF,AAAIE;;AAKnB,AAAA,AAAeC,AAAQV;AAAvB,AACE,AAAI,AAAA,AAAYW;AACd,AAAUhB,AAASK;;AACnB,AAAWL,AAASK","names":["me.tonsky.persistent-sorted-set.arrays/if-cljs","env","then","else","me.tonsky.persistent-sorted-set.arrays/make-array","size","js/Array","me.tonsky.persistent-sorted-set.arrays/into-array","aseq","cljs.core.reduce","a","x","me.tonsky.persistent-sorted-set.arrays/aclone","from","me.tonsky.persistent-sorted-set.arrays/aconcat","b","me.tonsky.persistent-sorted-set.arrays/amap","f","arr","me.tonsky.persistent-sorted-set.arrays/asort","cmp","me.tonsky.persistent-sorted-set.arrays/array?","cljs.core/*target*"],"sourcesContent":["(ns ^:no-doc me.tonsky.persistent-sorted-set.arrays\n  (:require\n    [clojure.string :as str])\n  (:refer-clojure :exclude [make-array into-array array amap aget aset alength array? aclone])\n  #?(:cljs (:require-macros me.tonsky.persistent-sorted-set.arrays))\n  #?(:clj  (:import [java.util Arrays])))\n\n\n(defn- if-cljs [env then else]\n  (if (:ns env) then else))\n\n\n#?(:cljs\n   (defn ^array make-array [size] (js/Array. size))\n   :clj \n   (defn make-array ^{:tag \"[[Ljava.lang.Object;\"} [size]\n     (clojure.core/make-array java.lang.Object size)))\n\n\n#?(:cljs\n   (defn ^array into-array [aseq]\n     (reduce (fn [a x] (.push a x) a) (js/Array.) aseq))\n   :clj\n   (defn into-array ^{:tag \"[[Ljava.lang.Object;\"} [aseq]\n     (clojure.core/into-array java.lang.Object aseq)))\n\n\n#?(:clj\n  (defmacro aget [arr i]\n    (if-cljs &env\n      (list 'js* \"(~{}[~{}])\" arr i)\n     `(clojure.lang.RT/aget ~(vary-meta arr assoc :tag \"[[Ljava.lang.Object;\") (int ~i)))))\n\n\n#?(:clj\n  (defmacro alength [arr]\n    (if-cljs &env\n      (-> (list 'js* \"~{}.length\" arr)\n          (vary-meta assoc :tag 'number))\n     `(clojure.lang.RT/alength ~(vary-meta arr assoc :tag \"[[Ljava.lang.Object;\")))))\n\n\n#?(:clj\n  (defmacro aset [arr i v]\n    (if-cljs &env\n      (list 'js* \"(~{}[~{}] = ~{})\" arr i v)\n     `(clojure.lang.RT/aset ~(vary-meta arr assoc :tag \"[[Ljava.lang.Object;\") (int ~i) ~v))))\n\n\n#?(:clj\n  (defmacro array [& args]\n    (if-cljs &env\n      (->\n        (list* 'js* (str \"[\" (str/join \",\" (repeat (count args) \"~{}\")) \"]\") args)\n        (vary-meta assoc :tag 'array))\n      (let [len (count args)]\n        (if (zero? len)\n          'clojure.lang.RT/EMPTY_ARRAY\n         `(let [arr# (clojure.core/make-array java.lang.Object ~len)]\n            (doto ^{:tag \"[[Ljava.lang.Object;\"} arr#\n            ~@(map #(list 'aset % (nth args %)) (range len)))))))))\n\n\n#?(:clj\n  (defmacro acopy [from from-start from-end to to-start]\n    (if-cljs &env\n     `(let [l# (- ~from-end ~from-start)]\n        (dotimes [i# l#]\n          (aset ~to (+ i# ~to-start) (aget ~from (+ i# ~from-start)))))\n     `(let [l# (- ~from-end ~from-start)]\n        (when (pos? l#)\n          (System/arraycopy ~from ~from-start ~to ~to-start l#))))))\n\n\n(defn aclone [from]\n  #?(:clj  (Arrays/copyOf ^{:tag \"[[Ljava.lang.Object;\"} from (alength from))\n     :cljs (.slice from 0)))\n\n\n(defn aconcat [a b]\n  #?(:cljs (.concat a b)\n     :clj  (let [al  (alength a)\n                 bl  (alength b)\n                 res (Arrays/copyOf ^{:tag \"[[Ljava.lang.Object;\"} a (+ al bl))]\n             (System/arraycopy ^{:tag \"[[Ljava.lang.Object;\"} b 0 res al bl)\n             res)))\n\n\n#?(:cljs\n   (defn amap [f arr]\n     (.map arr f))\n   :clj\n   (defn amap \n     ([f arr]\n      (amap f Object arr))\n     ([f type arr] ;; TODO check if faster in Java\n      (let [res (clojure.core/make-array type (alength arr))]\n        (dotimes [i (alength arr)]\n          (aset res i (f (aget arr i))))\n        res))))\n\n\n(defn asort [arr cmp]\n  #?(:cljs (.sort arr cmp)\n     :clj  (doto arr (Arrays/parallelSort cmp))))\n\n\n#?(:cljs\n   (defn ^boolean array? [x]\n     (if (identical? *target* \"nodejs\")\n       (.isArray js/Array x)\n       (instance? js/Array x)))\n   :clj\n   (defn array? [^Object x]\n     (-> x .getClass .isArray)))\n\n\n#?(:clj\n   (defmacro alast [arr]\n     `(let [arr# ~arr]\n        (aget arr# (dec (alength arr#))))))\n\n\n#?(:clj\n   (defmacro half [x]\n     `(unsigned-bit-shift-right ~x 1)))\n\n\n#?(:clj\n  (def array-type\n    (memoize\n      (fn [type]\n        (.getClass ^Object (java.lang.reflect.Array/newInstance ^Class type 0))))))\n"]}